/**
  * \file Rte.c
  *
  * \brief Autosar RTE Runtime Environment
  *
  * This file contains the generated Rte source code
  *
  * \author Elektrobit Automotive GmbH, 91058 Erlangen, Germany
  *
  * Copyright 2005-2010 Elektrobit Automotive GmbH
  * All rights exclusively reserved for Elektrobit Automotive GmbH,
  * unless expressly agreed to otherwise.
  */

 /*
  * This file has been automatically generated by
  * tresos RTE Generator Version 5.0.17
  * on Wed Feb 27 10:02:51 CET 2013. !!!IGNORE-LINE!!!
  */

 /* Misra deviations:
  * 1) Deviation against MISRA-C:1998 Rule 11 (required)
  *      and               MISRA-C:2004 Rule 5.1 (required)
  *      Description:
  *      Identifiers (internal and external) shall not rely
  *      on the significance of more than 31 characters.
  *      Reason:
  *      The defined RTE naming convention may result in
  *      identifiers with more than 31 characters.
  *      The compliance to this rule is under user's control.
  *
  * 2) Deviation against MISRA-C:1998 Rule 45 (required)
  *      and               MISRA-C:2004 Rule 11.4 (advisory)
  *      Description:
  *      A cast should not be performed between a pointer to
  *      object type and a different pointer to object type.
  *      Reason:
  *      The data handle variable of a provide data element
  *      may have a status buffer because it can be shared
  *      with a require data element. However the data handle
  *      section entry for the provide data
  *      element instance must not have a status type.
  *      Thus, the Rte makes a cast.
  *
  * 3) Deviation against MISRA-C:1998 Rule 87 (required)
  *      and               MISRA-C:2004 Rule 19.1 (advisory)
  *      Description:
  *      include statements in a file shall only be preceded
  *      by other pre-processor directives or comments.
  *      Reason:
  *      This is explicitly required by AUTOSAR
  *      Specification of Memory Mapping
  *
  */

 /* \addtogroup RTE Runtime Environment
  * @{ */

/*==================[inclusions]=============================================*/

#include <os.h>                     /* OS header file */
#include <Rte.h>                    /* RTE header file */
#include <Rte_Intern.h>             /* RTE internal header file */
#include <Rte_Main.h>               /* RTE main header file */
#include <Rte_Type.h>               /* RTE types header file */
#include <Rte_Hook.h>               /* RTE VFB tracing header file */
#include <Rte_Cbk.h>                /* RTE callback header file */
#include <Com.h>                    /* COM header file */

#if (!defined RTE_CORE)
#define RTE_CORE              /* define symbol so that only the part of
* the application header files is included
* which is relevant for the RTE Core */
#endif

#include <Rte_SWC_ModifyEcho.h>      /* application header file of component SWC_ModifyEcho */

#include <Rte_SWC_CyclicCounter.h>      /* application header file of component SWC_CyclicCounter */

#include <Rte_EcuStateManager.h>      /* application header file of component EcuStateManager */

/*==================[macros]=================================================*/

/*==================[type definitions]=======================================*/

/*==================[external function declarations]=========================*/

/*==================[internal function declarations]=========================*/

/*==================[external data]==========================================*/

/*==================[internal data]==========================================*/

#define RTE_START_SEC_VAR_UNSPECIFIED
#include "MemMap.h"

/*------------------[flags]--------------------------------------------------*/

STATIC VAR(boolean, RTE_VAR) Rte_Started = FALSE;

/*------------------[data handle variable definitions]-----------------------*/

VAR(Rte_DE_UInt8, RTE_VAR) Rte_DataHandleBuffer_0;

/*------------------[inter runnable variable definitions]--------------------*/

STATIC VAR(UInt8, RTE_VAR)Rte_Irv_SWC_CyclicCounter_CurrentCounterValue = 0U;

/*------------------[inter runnable variable handle definitions]-------------*/

/*------------------[feedback status buffer definitions]---------------------*/

/*------------------[receive queue definitions]------------------------------*/

STATIC VAR(Rte_ReceiveQueue_0_Type, RTE_VAR) Rte_ReceiveQueue_0;

/*------------------[receive buffer definitions]-----------------------------*/

/*------------------[shared buffer definitions]-----------------------------*/

/*------------------[client request buffer definitions]----------------------*/

/*------------------[invocation queue definitions]---------------------------*/

/*------------------[mode receive queue definitions]-------------------------*/

/*------------------[task RTE event buffer]----------------------------------*/

/*------------------[per instance memory]------------------------------------*/

/*------------------[mode variable definitions]------------------------------*/

#define RTE_STOP_SEC_VAR_UNSPECIFIED
#include "MemMap.h"

/*------------------[mode disabling dependencies]----------------------------*/

/*------------------[calibration buffers]------------------------------------*/

/*==================[external constants]=====================================*/

/*==================[internal constants]=====================================*/

#define RTE_START_SEC_CONST_UNSPECIFIED
#include "MemMap.h"

/*------------------[component data structure definitions]-------------------*/

CONST(Rte_CDS_SWC_ModifyEcho, RTE_CONST) Rte_Instance_SWC_ModifyEcho =
{
  /* Data Handles section */
  &Rte_DataHandleBuffer_0,
  /* PIM handles section */
  /* Inter runnable variable section */
  /* Calibration parameters handles section */
  /* Exclusive areas handles section */
  /* Port API section */
  /* Inter Runnable Variable API Section */
  /* Vendor specific information: None */
};

CONST(Rte_CDS_SWC_CyclicCounter, RTE_CONST) Rte_Instance_SWC_CyclicCounter =
{
  /* Data Handles section */
  /* PIM handles section */
  /* Inter runnable variable section */
  /* Calibration parameters handles section */
  /* Exclusive areas handles section */
  /* Port API section */
  /* Inter Runnable Variable API Section */
  /* Vendor specific information: None */
  0 /* dummy entry */
};

CONST(Rte_CDS_EcuStateManager, RTE_CONST) Rte_Instance_EcuStateManager =
{
  /* Data Handles section */
  /* PIM handles section */
  /* Inter runnable variable section */
  /* Calibration parameters handles section */
  /* Exclusive areas handles section */
  /* Port API section */
  /* Inter Runnable Variable API Section */
  /* Vendor specific information: None */
  0 /* dummy entry */
};

/*------------------[instance handle definitions]----------------------------*/
CONSTP2CONST(Rte_CDS_SWC_ModifyEcho, RTE_CONST, RTE_CONST) Rte_Inst_SWC_ModifyEcho = &Rte_Instance_SWC_ModifyEcho;
CONSTP2CONST(Rte_CDS_SWC_CyclicCounter, RTE_CONST, RTE_CONST) Rte_Inst_SWC_CyclicCounter = &Rte_Instance_SWC_CyclicCounter;
CONSTP2CONST(Rte_CDS_EcuStateManager, RTE_CONST, RTE_CONST) Rte_Inst_EcuStateManager = &Rte_Instance_EcuStateManager;

#define RTE_STOP_SEC_CONST_UNSPECIFIED
#include "MemMap.h"

/*==================[external function definitions]==========================*/

#define RTE_START_SEC_CODE
#include "MemMap.h"

/*------------------[API function definitions]-------------------------------*/

FUNC(Std_ReturnType, RTE_CODE) Rte_Send_SWC_ModifyEcho_P_SpecialRequest_EventMessage (UInt8 data)
{
  Std_ReturnType Rte_Status = RTE_E_OK;

  Rte_SendHook_SWC_ModifyEcho_P_SpecialRequest_EventMessage_Start(data);

  (void) GetResource (Rte_Res_0);
  if ((Rte_ReceiveQueue_0.head == Rte_ReceiveQueue_0.tail + 1U) ||
  ((Rte_ReceiveQueue_0.head == 0U) &&
  (Rte_ReceiveQueue_0.tail == 8U)))
  {
    Rte_ReceiveQueue_0.overflow = TRUE;
    Rte_Status = RTE_E_LIMIT;
  }
  else
  {
    Rte_ReceiveQueue_0.queue[Rte_ReceiveQueue_0.tail] = data;
    Rte_ReceiveQueue_0.tail = (Rte_ReceiveQueue_0.tail + 1U) % 9U;
  }
  (void) ReleaseResource (Rte_Res_0);

  Rte_SendHook_SWC_ModifyEcho_P_SpecialRequest_EventMessage_Return(data);
  return Rte_Status;

} /* FUNC(Std_ReturnType, RTE_CODE) Rte_Send_SWC_ModifyEcho_P_SpecialRequest_EventMessage (UInt8 data) */

FUNC(Std_ReturnType, RTE_CODE) Rte_Read_SWC_ModifyEcho_P_NewCounterIn_CounterValue (P2VAR(UInt8, AUTOMATIC, RTE_APPL_DATA) data)
{
  Std_ReturnType Rte_Status = RTE_E_OK;

  Rte_ReadHook_SWC_ModifyEcho_P_NewCounterIn_CounterValue_Start(data);
  (void) Com_ReceiveSignal(SGCounterIn, (P2VAR(void, AUTOMATIC, COM_APPL_DATA)) data);

  Rte_ReadHook_SWC_ModifyEcho_P_NewCounterIn_CounterValue_Return(data);

  return Rte_Status;

} /* FUNC(Std_ReturnType, RTE_CODE) Rte_Read_SWC_ModifyEcho_P_NewCounterIn_CounterValue (P2VAR(UInt8, AUTOMATIC, RTE_APPL_DATA) data) */

FUNC(Std_ReturnType, RTE_CODE) Rte_Call_SWC_ModifyEcho_CS_EchoResult_SetCounterAndAdd (UInt8 newCounterValue, P2VAR(UInt8, AUTOMATIC, RTE_APPL_DATA) ReturnSum)
{
  Std_ReturnType Rte_Status = RTE_E_OK;

  Rte_CallHook_SWC_ModifyEcho_CS_EchoResult_SetCounterAndAdd_Start(newCounterValue, ReturnSum);

  Rte_Runnable_SWC_CyclicCounter_R_SetCounterAndAdd_Start();
  SWC_cyclic_R_SetCounter(newCounterValue, ReturnSum);
  Rte_Runnable_SWC_CyclicCounter_R_SetCounterAndAdd_Return();

  Rte_CallHook_SWC_ModifyEcho_CS_EchoResult_SetCounterAndAdd_Return(newCounterValue, ReturnSum);

  return Rte_Status;

} /* FUNC(Std_ReturnType, RTE_CODE) Rte_Call_SWC_ModifyEcho_CS_EchoResult_SetCounterAndAdd (UInt8 newCounterValue, P2VAR(UInt8, AUTOMATIC, RTE_APPL_DATA) ReturnSum) */

FUNC(UInt8, RTE_CODE) Rte_IrvRead_SWC_CyclicCounter_R_SetCounterAndAdd_CurrentCounterValue (void) 
{

  UInt8 InternalBuffer;

  Rte_IrvReadHook_SWC_CyclicCounter_R_SetCounterAndAdd_CurrentCounterValue_Start();

  InternalBuffer = Rte_Irv_SWC_CyclicCounter_CurrentCounterValue;

  Rte_IrvReadHook_SWC_CyclicCounter_R_SetCounterAndAdd_CurrentCounterValue_Return();

  return InternalBuffer;

} /* FUNC(UInt8, RTE_CODE) Rte_IrvRead_SWC_CyclicCounter_R_SetCounterAndAdd_CurrentCounterValue (void */
FUNC(void, RTE_CODE) Rte_IrvWrite_SWC_CyclicCounter_R_SetCounterAndAdd_CurrentCounterValue (UInt8 data)
{
  Rte_IrvWriteHook_SWC_CyclicCounter_R_SetCounterAndAdd_CurrentCounterValue_Start(data);

  Rte_Irv_SWC_CyclicCounter_CurrentCounterValue = data;

  Rte_IrvWriteHook_SWC_CyclicCounter_R_SetCounterAndAdd_CurrentCounterValue_Return(data);

} /* FUNC(void, RTE_CODE) Rte_IrvWrite_SWC_CyclicCounter_R_SetCounterAndAdd_CurrentCounterValue (UInt8 data) */
FUNC(UInt8, RTE_CODE) Rte_IrvRead_SWC_CyclicCounter_R_Cyclic_CurrentCounterValue (void) 
{

  UInt8 InternalBuffer;

  Rte_IrvReadHook_SWC_CyclicCounter_R_Cyclic_CurrentCounterValue_Start();

  InternalBuffer = Rte_Irv_SWC_CyclicCounter_CurrentCounterValue;

  Rte_IrvReadHook_SWC_CyclicCounter_R_Cyclic_CurrentCounterValue_Return();

  return InternalBuffer;

} /* FUNC(UInt8, RTE_CODE) Rte_IrvRead_SWC_CyclicCounter_R_Cyclic_CurrentCounterValue (void */
FUNC(void, RTE_CODE) Rte_IrvWrite_SWC_CyclicCounter_R_Cyclic_CurrentCounterValue (UInt8 data)
{
  Rte_IrvWriteHook_SWC_CyclicCounter_R_Cyclic_CurrentCounterValue_Start(data);

  Rte_Irv_SWC_CyclicCounter_CurrentCounterValue = data;

  Rte_IrvWriteHook_SWC_CyclicCounter_R_Cyclic_CurrentCounterValue_Return(data);

} /* FUNC(void, RTE_CODE) Rte_IrvWrite_SWC_CyclicCounter_R_Cyclic_CurrentCounterValue (UInt8 data) */

FUNC(Std_ReturnType, RTE_CODE) Rte_Write_SWC_CyclicCounter_P_CounterOut_CounterValue (UInt8 data)
{
  Std_ReturnType Rte_Status = RTE_E_OK;

  Rte_WriteHook_SWC_CyclicCounter_P_CounterOut_CounterValue_Start(data);

  Rte_ComHook_SGCounterOut_SigTx ( (P2VAR(void, AUTOMATIC, RTE_APPL_DATA)) &data );
  if (Com_SendSignal (SGCounterOut, (P2VAR(void, AUTOMATIC, COM_APPL_DATA)) &data) != E_OK)
  {
    Rte_Status = RTE_E_COM_STOPPED;
  }

  Rte_WriteHook_SWC_CyclicCounter_P_CounterOut_CounterValue_Return(data);
  return Rte_Status;

} /* FUNC(Std_ReturnType, RTE_CODE) Rte_Write_SWC_CyclicCounter_P_CounterOut_CounterValue (UInt8 data) */

FUNC(Std_ReturnType, RTE_CODE) Rte_Receive_SWC_CyclicCounter_P_SpecialHandling_EventMessage (P2VAR(UInt8, AUTOMATIC, RTE_APPL_DATA) data)
{
  Std_ReturnType Rte_Status = RTE_E_OK;

  Rte_ReceiveHook_SWC_CyclicCounter_P_SpecialHandling_EventMessage_Start(data);
  (void) GetResource (Rte_Res_0);
  if ( Rte_ReceiveQueue_0.head == Rte_ReceiveQueue_0.tail)
  {
    Rte_Status = RTE_E_NO_DATA;
  }
  else
  {
    if (Rte_ReceiveQueue_0.overflow == TRUE )
    {
      Rte_Status = Rte_Status | RTE_E_LOST_DATA;
    }
    Rte_ReceiveQueue_0.overflow = FALSE;
    *data = Rte_ReceiveQueue_0.queue[Rte_ReceiveQueue_0.head];
    Rte_ReceiveQueue_0.head = (Rte_ReceiveQueue_0.head + 1U) % 9U;
  }
  (void) ReleaseResource (Rte_Res_0);

  Rte_ReceiveHook_SWC_CyclicCounter_P_SpecialHandling_EventMessage_Return(data);

  return Rte_Status;

} /* FUNC(Std_ReturnType, RTE_CODE) Rte_Receive_SWC_CyclicCounter_P_SpecialHandling_EventMessage (P2VAR(UInt8, AUTOMATIC, RTE_APPL_DATA) data) */

FUNC(Std_ReturnType, RTE_CODE) Rte_Switch_EcuStateManager_currentMode_currentMode (Rte_ModeType_EcuM_Mode mode)
{
  Rte_SwitchHook_EcuStateManager_currentMode_currentMode_Start(mode);
  Rte_SwitchHook_EcuStateManager_currentMode_currentMode_Return(mode);
  TS_PARAM_UNUSED(mode);
  return RTE_E_OK;

} /* FUNC(Std_ReturnType, RTE_CODE) Rte_Switch_EcuStateManager_currentMode_currentMode (Rte_ModeType_EcuM_Mode mode) */

FUNC(Rte_ModeType_EcuM_Mode, RTE_CODE) Rte_Mode_EcuStateManager_currentMode_currentMode (void)
{
  Rte_ModeHook_EcuStateManager_currentMode_currentMode_Start();
  Rte_ModeHook_EcuStateManager_currentMode_currentMode_Return();

  return RTE_MODE_EcuM_Mode_STARTUP;

} /* FUNC(Rte_ModeType_EcuM_Mode, RTE_CODE) Rte_Mode_EcuStateManager_currentMode_currentMode (void) */

/*------------------[task bodies]--------------------------------------------*/

TASK(Rte_EventTask)
{
  /* scenario B2 */

  /* local buffer for event masks */
  EventMaskType CurrentEvent;

  boolean ShutdownFlag = FALSE;
  Rte_Task_Dispatch(Rte_EventTask);

  while (!ShutdownFlag) 
  {
    (void) Rte_WaitGetClearEvent(Rte_OSShutdownEvent  | Rte_OSTriggerRunnableEvent_0_0, &CurrentEvent, Rte_EventTask);

    if (CurrentEvent & Rte_OSShutdownEvent)
    {
      /* shutdown notification arrived, clear all events */
      ShutdownFlag = TRUE;
    }

    if (CurrentEvent & Rte_OSTriggerRunnableEvent_0_0)
    {
      /* RunnableEntity R_ModifyEcho */
      Rte_Runnable_SWC_ModifyEcho_R_ModifyEcho_Start();
      SWC_ModifyEcho_R_ModifyEcho();
      Rte_Runnable_SWC_ModifyEcho_R_ModifyEcho_Return();

    }

  } /* while (!ShutdownFlag) */

  (void)TerminateTask();
} /* TASK(Rte_EventTask) */

TASK(Rte_TimedTask)
{
  /* scenario A1/B1 (A1) */
  Rte_Task_Dispatch(Rte_TimedTask);

  {

    /* RunnableEntity R_Cyclic */
    Rte_Runnable_SWC_CyclicCounter_R_Cyclic_Start();
    SWC_cyclic_R_Cyclic();
    Rte_Runnable_SWC_CyclicCounter_R_Cyclic_Return();

  }

  (void)TerminateTask();
} /* TASK(Rte_TimedTask) */

/*------------------[callbacks]----------------------------------------------*/

FUNC(void, RTE_CODE) Rte_COMCbk_SGCounterIn (void)
{
  Rte_ComHook_SGCounterIn();

  if (Rte_Started == TRUE)
  {

    Rte_SetEvent_DRE_Rte_EventTask_0();

  } /* if (Rte_Started == TRUE) */

} /* FUNC(void, RTE_CODE) Rte_COMCbk_SGCounterIn (void) */

/*------------------[lifecycle API]------------------------------------------*/

FUNC(Std_ReturnType, RTE_CODE) Rte_Start (void)
{
  Std_ReturnType Rte_Status = RTE_E_OK;

  if (Rte_Started == FALSE)
  {

    Rte_Task_Activate (Rte_EventTask);
    if ( ActivateTask (Rte_EventTask) != E_OK )
    {
      Rte_Status = RTE_E_LIMIT;
    }

    if ( Rte_StartScheduleTable_Rte_DefaultScheduleTable() != E_OK )
    {
      Rte_Status = RTE_E_LIMIT;
    }

    if (Rte_Status == RTE_E_OK)
    {
      Rte_Started = TRUE;
    }

  }
  else
  {
    Rte_Status = RTE_E_LIMIT;
  } /* end if (Rte_Started == FALSE) */

  return Rte_Status;
} /* Rte_Start */

FUNC(Std_ReturnType, RTE_CODE) Rte_Stop (void)
{
  Std_ReturnType Rte_Status = RTE_E_OK;

  if (Rte_Started == TRUE) 
  {

    if ( StopScheduleTable(Rte_DefaultScheduleTable) != E_OK )
    {
      Rte_Status = RTE_E_LIMIT;
    }

    Rte_Task_SetEvent (Rte_EventTask, Rte_OSShutdownEvent);
    if ( SetEvent (Rte_EventTask, Rte_OSShutdownEvent) != E_OK )
    {
      Rte_Status = RTE_E_LIMIT;
    }

    if (Rte_Status == RTE_E_OK)
    {
      Rte_Started = FALSE;
    }

  }
  else
  {
    Rte_Status = RTE_E_LIMIT;
  } /* if (Rte_Started == TRUE) */

  return Rte_Status;

} /* Rte_Stop */

/*==================[internal function definitions]==========================*/

#ifndef Rte_WaitGetClearEvent

FUNC(StatusType, RTE_CODE) Rte_WaitGetClearEvent
(
VAR(EventMaskType, RTE_VAR) eventToWait,
P2VAR(EventMaskType, AUTOMATIC, RTE_VAR) eventReceived,
VAR(TaskType, RTE_VAR) myTaskId
)
{
  Rte_Task_WaitEvent (myTaskId, eventToWait);
  (void) WaitEvent(eventToWait);
  Rte_Task_WaitEventRet (myTaskId, eventToWait);
  (void) GetEvent(myTaskId, eventReceived);
  (void) ClearEvent(*eventReceived);
  return E_OK;
}

#endif

#define RTE_STOP_SEC_CODE
#include "MemMap.h"
/** @} doxygen end group definition */
/*==================[end of file]============================================*/

